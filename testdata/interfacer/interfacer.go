// generated by "charlatan -dir=testdata/interfacer -output=testdata/interfacer/interfacer.go Interfacer".  DO NOT EDIT.

package main

import (
	"reflect"
	"testing"
)

// InterfacerInterfaceInvocation represents a single call of FakeInterfacer.Interface
type InterfacerInterfaceInvocation struct {
	Parameters struct {
		Ident1 interface{}
	}
	Results struct {
		Ident2 interface{}
	}
}

// InterfacerNamedInterfaceInvocation represents a single call of FakeInterfacer.NamedInterface
type InterfacerNamedInterfaceInvocation struct {
	Parameters struct {
		A interface{}
	}
	Results struct {
		Z interface{}
	}
}

/*
FakeInterfacer is a mock implementation of Interfacer for testing.
Use it in your tests as in this example:

	package example

	func TestWithInterfacer(t *testing.T) {
		f := &main.FakeInterfacer{
			InterfaceHook: func(ident1 interface{}) (ident2 interface{}) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeInterface ...
		f.AssertInterfaceCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeInterface.
*/
type FakeInterfacer struct {
	InterfaceHook      func(interface{}) interface{}
	NamedInterfaceHook func(interface{}) interface{}

	InterfaceCalls      []*InterfacerInterfaceInvocation
	NamedInterfaceCalls []*InterfacerNamedInterfaceInvocation
}

// NewFakeInterfacerDefaultPanic returns an instance of FakeInterfacer with all hooks configured to panic
func NewFakeInterfacerDefaultPanic() *FakeInterfacer {
	return &FakeInterfacer{
		InterfaceHook: func(interface{}) (ident2 interface{}) {
			panic("Unexpected call to Interfacer.Interface")
		},
		NamedInterfaceHook: func(interface{}) (z interface{}) {
			panic("Unexpected call to Interfacer.NamedInterface")
		},
	}
}

// NewFakeInterfacerDefaultFatal returns an instance of FakeInterfacer with all hooks configured to call t.Fatal
func NewFakeInterfacerDefaultFatal(t *testing.T) *FakeInterfacer {
	return &FakeInterfacer{
		InterfaceHook: func(interface{}) (ident2 interface{}) {
			t.Fatal("Unexpected call to Interfacer.Interface")
			return
		},
		NamedInterfaceHook: func(interface{}) (z interface{}) {
			t.Fatal("Unexpected call to Interfacer.NamedInterface")
			return
		},
	}
}

// NewFakeInterfacerDefaultError returns an instance of FakeInterfacer with all hooks configured to call t.Error
func NewFakeInterfacerDefaultError(t *testing.T) *FakeInterfacer {
	return &FakeInterfacer{
		InterfaceHook: func(interface{}) (ident2 interface{}) {
			t.Error("Unexpected call to Interfacer.Interface")
			return
		},
		NamedInterfaceHook: func(interface{}) (z interface{}) {
			t.Error("Unexpected call to Interfacer.NamedInterface")
			return
		},
	}
}

func (f *FakeInterfacer) Reset() {
	f.InterfaceCalls = []*InterfacerInterfaceInvocation{}
	f.NamedInterfaceCalls = []*InterfacerNamedInterfaceInvocation{}
}

func (_f1 *FakeInterfacer) Interface(ident1 interface{}) (ident2 interface{}) {
	invocation := new(InterfacerInterfaceInvocation)

	invocation.Parameters.Ident1 = ident1

	ident2 = _f1.InterfaceHook(ident1)

	invocation.Results.Ident2 = ident2

	_f1.InterfaceCalls = append(_f1.InterfaceCalls, invocation)

	return
}

// InterfaceCalled returns true if FakeInterfacer.Interface was called
func (f *FakeInterfacer) InterfaceCalled() bool {
	return len(f.InterfaceCalls) != 0
}

// AssertInterfaceCalled calls t.Error if FakeInterfacer.Interface was not called
func (f *FakeInterfacer) AssertInterfaceCalled(t *testing.T) {
	t.Helper()
	if len(f.InterfaceCalls) == 0 {
		t.Error("FakeInterfacer.Interface not called, expected at least one")
	}
}

// InterfaceNotCalled returns true if FakeInterfacer.Interface was not called
func (f *FakeInterfacer) InterfaceNotCalled() bool {
	return len(f.InterfaceCalls) == 0
}

// AssertInterfaceNotCalled calls t.Error if FakeInterfacer.Interface was called
func (f *FakeInterfacer) AssertInterfaceNotCalled(t *testing.T) {
	t.Helper()
	if len(f.InterfaceCalls) != 0 {
		t.Error("FakeInterfacer.Interface called, expected none")
	}
}

// InterfaceCalledOnce returns true if FakeInterfacer.Interface was called exactly once
func (f *FakeInterfacer) InterfaceCalledOnce() bool {
	return len(f.InterfaceCalls) == 1
}

// AssertInterfaceCalledOnce calls t.Error if FakeInterfacer.Interface was not called exactly once
func (f *FakeInterfacer) AssertInterfaceCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.InterfaceCalls) != 1 {
		t.Errorf("FakeInterfacer.Interface called %d times, expected 1", len(f.InterfaceCalls))
	}
}

// InterfaceCalledN returns true if FakeInterfacer.Interface was called at least n times
func (f *FakeInterfacer) InterfaceCalledN(n int) bool {
	return len(f.InterfaceCalls) >= n
}

// AssertInterfaceCalledN calls t.Error if FakeInterfacer.Interface was called less than n times
func (f *FakeInterfacer) AssertInterfaceCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.InterfaceCalls) < n {
		t.Errorf("FakeInterfacer.Interface called %d times, expected >= %d", len(f.InterfaceCalls), n)
	}
}

// InterfaceCalledWith returns true if FakeInterfacer.Interface was called with the given values
func (_f2 *FakeInterfacer) InterfaceCalledWith(ident1 interface{}) (found bool) {
	for _, call := range _f2.InterfaceCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertInterfaceCalledWith calls t.Error if FakeInterfacer.Interface was not called with the given values
func (_f3 *FakeInterfacer) AssertInterfaceCalledWith(t *testing.T, ident1 interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f3.InterfaceCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeInterfacer.Interface not called with expected parameters")
	}
}

// InterfaceCalledOnceWith returns true if FakeInterfacer.Interface was called exactly once with the given values
func (_f4 *FakeInterfacer) InterfaceCalledOnceWith(ident1 interface{}) bool {
	var count int
	for _, call := range _f4.InterfaceCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertInterfaceCalledOnceWith calls t.Error if FakeInterfacer.Interface was not called exactly once with the given values
func (_f5 *FakeInterfacer) AssertInterfaceCalledOnceWith(t *testing.T, ident1 interface{}) {
	t.Helper()
	var count int
	for _, call := range _f5.InterfaceCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeInterfacer.Interface called %d times with expected parameters, expected one", count)
	}
}

// InterfaceResultsForCall returns the result values for the first call to FakeInterfacer.Interface with the given values
func (_f6 *FakeInterfacer) InterfaceResultsForCall(ident1 interface{}) (ident2 interface{}, found bool) {
	for _, call := range _f6.InterfaceCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f7 *FakeInterfacer) NamedInterface(a interface{}) (z interface{}) {
	invocation := new(InterfacerNamedInterfaceInvocation)

	invocation.Parameters.A = a

	z = _f7.NamedInterfaceHook(a)

	invocation.Results.Z = z

	_f7.NamedInterfaceCalls = append(_f7.NamedInterfaceCalls, invocation)

	return
}

// NamedInterfaceCalled returns true if FakeInterfacer.NamedInterface was called
func (f *FakeInterfacer) NamedInterfaceCalled() bool {
	return len(f.NamedInterfaceCalls) != 0
}

// AssertNamedInterfaceCalled calls t.Error if FakeInterfacer.NamedInterface was not called
func (f *FakeInterfacer) AssertNamedInterfaceCalled(t *testing.T) {
	t.Helper()
	if len(f.NamedInterfaceCalls) == 0 {
		t.Error("FakeInterfacer.NamedInterface not called, expected at least one")
	}
}

// NamedInterfaceNotCalled returns true if FakeInterfacer.NamedInterface was not called
func (f *FakeInterfacer) NamedInterfaceNotCalled() bool {
	return len(f.NamedInterfaceCalls) == 0
}

// AssertNamedInterfaceNotCalled calls t.Error if FakeInterfacer.NamedInterface was called
func (f *FakeInterfacer) AssertNamedInterfaceNotCalled(t *testing.T) {
	t.Helper()
	if len(f.NamedInterfaceCalls) != 0 {
		t.Error("FakeInterfacer.NamedInterface called, expected none")
	}
}

// NamedInterfaceCalledOnce returns true if FakeInterfacer.NamedInterface was called exactly once
func (f *FakeInterfacer) NamedInterfaceCalledOnce() bool {
	return len(f.NamedInterfaceCalls) == 1
}

// AssertNamedInterfaceCalledOnce calls t.Error if FakeInterfacer.NamedInterface was not called exactly once
func (f *FakeInterfacer) AssertNamedInterfaceCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.NamedInterfaceCalls) != 1 {
		t.Errorf("FakeInterfacer.NamedInterface called %d times, expected 1", len(f.NamedInterfaceCalls))
	}
}

// NamedInterfaceCalledN returns true if FakeInterfacer.NamedInterface was called at least n times
func (f *FakeInterfacer) NamedInterfaceCalledN(n int) bool {
	return len(f.NamedInterfaceCalls) >= n
}

// AssertNamedInterfaceCalledN calls t.Error if FakeInterfacer.NamedInterface was called less than n times
func (f *FakeInterfacer) AssertNamedInterfaceCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.NamedInterfaceCalls) < n {
		t.Errorf("FakeInterfacer.NamedInterface called %d times, expected >= %d", len(f.NamedInterfaceCalls), n)
	}
}

// NamedInterfaceCalledWith returns true if FakeInterfacer.NamedInterface was called with the given values
func (_f8 *FakeInterfacer) NamedInterfaceCalledWith(a interface{}) (found bool) {
	for _, call := range _f8.NamedInterfaceCalls {
		if reflect.DeepEqual(call.Parameters.A, a) {
			found = true
			break
		}
	}

	return
}

// AssertNamedInterfaceCalledWith calls t.Error if FakeInterfacer.NamedInterface was not called with the given values
func (_f9 *FakeInterfacer) AssertNamedInterfaceCalledWith(t *testing.T, a interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f9.NamedInterfaceCalls {
		if reflect.DeepEqual(call.Parameters.A, a) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeInterfacer.NamedInterface not called with expected parameters")
	}
}

// NamedInterfaceCalledOnceWith returns true if FakeInterfacer.NamedInterface was called exactly once with the given values
func (_f10 *FakeInterfacer) NamedInterfaceCalledOnceWith(a interface{}) bool {
	var count int
	for _, call := range _f10.NamedInterfaceCalls {
		if reflect.DeepEqual(call.Parameters.A, a) {
			count++
		}
	}

	return count == 1
}

// AssertNamedInterfaceCalledOnceWith calls t.Error if FakeInterfacer.NamedInterface was not called exactly once with the given values
func (_f11 *FakeInterfacer) AssertNamedInterfaceCalledOnceWith(t *testing.T, a interface{}) {
	t.Helper()
	var count int
	for _, call := range _f11.NamedInterfaceCalls {
		if reflect.DeepEqual(call.Parameters.A, a) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeInterfacer.NamedInterface called %d times with expected parameters, expected one", count)
	}
}

// NamedInterfaceResultsForCall returns the result values for the first call to FakeInterfacer.NamedInterface with the given values
func (_f12 *FakeInterfacer) NamedInterfaceResultsForCall(a interface{}) (z interface{}, found bool) {
	for _, call := range _f12.NamedInterfaceCalls {
		if reflect.DeepEqual(call.Parameters.A, a) {
			z = call.Results.Z
			found = true
			break
		}
	}

	return
}
