// generated by "charlatan -dir=testdata/funcer -output=testdata/funcer/funcer.go Funcer".  DO NOT EDIT.

package main

import "reflect"

// FuncerFuncParameterInvocation represents a single call of FakeFuncer.FuncParameter
type FuncerFuncParameterInvocation struct {
	Parameters struct {
		Ident1 func(string) string
	}
}

// FuncerFuncReturnInvocation represents a single call of FakeFuncer.FuncReturn
type FuncerFuncReturnInvocation struct {
	Results struct {
		Ident1 func(string) string
	}
}

// FuncerTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type FuncerTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeFuncer is a mock implementation of Funcer for testing.
Use it in your tests as in this example:

	package example

	func TestWithFuncer(t *testing.T) {
		f := &main.FakeFuncer{
			FuncParameterHook: func(ident1 func(string) string) () {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeFuncParameter ...
		f.AssertFuncParameterCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeFuncParameter.
*/
type FakeFuncer struct {
	FuncParameterHook func(func(string) string)
	FuncReturnHook    func() func(string) string

	FuncParameterCalls []*FuncerFuncParameterInvocation
	FuncReturnCalls    []*FuncerFuncReturnInvocation
}

// NewFakeFuncerDefaultPanic returns an instance of FakeFuncer with all hooks configured to panic
func NewFakeFuncerDefaultPanic() *FakeFuncer {
	return &FakeFuncer{
		FuncParameterHook: func(func(string) string) {
			panic("Unexpected call to Funcer.FuncParameter")
		},
		FuncReturnHook: func() (ident1 func(string) string) {
			panic("Unexpected call to Funcer.FuncReturn")
		},
	}
}

// NewFakeFuncerDefaultFatal returns an instance of FakeFuncer with all hooks configured to call t.Fatal
func NewFakeFuncerDefaultFatal(t_sym1 FuncerTestingT) *FakeFuncer {
	return &FakeFuncer{
		FuncParameterHook: func(func(string) string) {
			t_sym1.Fatal("Unexpected call to Funcer.FuncParameter")
			return
		},
		FuncReturnHook: func() (ident1 func(string) string) {
			t_sym1.Fatal("Unexpected call to Funcer.FuncReturn")
			return
		},
	}
}

// NewFakeFuncerDefaultError returns an instance of FakeFuncer with all hooks configured to call t.Error
func NewFakeFuncerDefaultError(t_sym2 FuncerTestingT) *FakeFuncer {
	return &FakeFuncer{
		FuncParameterHook: func(func(string) string) {
			t_sym2.Error("Unexpected call to Funcer.FuncParameter")
			return
		},
		FuncReturnHook: func() (ident1 func(string) string) {
			t_sym2.Error("Unexpected call to Funcer.FuncReturn")
			return
		},
	}
}

func (f *FakeFuncer) Reset() {
	f.FuncParameterCalls = []*FuncerFuncParameterInvocation{}
	f.FuncReturnCalls = []*FuncerFuncReturnInvocation{}
}

func (f_sym3 *FakeFuncer) FuncParameter(ident1 func(string) string) {
	if f_sym3.FuncParameterHook == nil {
		panic("Funcer.FuncParameter() called but FakeFuncer.FuncParameterHook is nil")
	}

	invocation_sym3 := new(FuncerFuncParameterInvocation)
	f_sym3.FuncParameterCalls = append(f_sym3.FuncParameterCalls, invocation_sym3)

	invocation_sym3.Parameters.Ident1 = ident1

	f_sym3.FuncParameterHook(ident1)

	return
}

// FuncParameterCalled returns true if FakeFuncer.FuncParameter was called
func (f *FakeFuncer) FuncParameterCalled() bool {
	return len(f.FuncParameterCalls) != 0
}

// AssertFuncParameterCalled calls t.Error if FakeFuncer.FuncParameter was not called
func (f *FakeFuncer) AssertFuncParameterCalled(t FuncerTestingT) {
	t.Helper()
	if len(f.FuncParameterCalls) == 0 {
		t.Error("FakeFuncer.FuncParameter not called, expected at least one")
	}
}

// FuncParameterNotCalled returns true if FakeFuncer.FuncParameter was not called
func (f *FakeFuncer) FuncParameterNotCalled() bool {
	return len(f.FuncParameterCalls) == 0
}

// AssertFuncParameterNotCalled calls t.Error if FakeFuncer.FuncParameter was called
func (f *FakeFuncer) AssertFuncParameterNotCalled(t FuncerTestingT) {
	t.Helper()
	if len(f.FuncParameterCalls) != 0 {
		t.Error("FakeFuncer.FuncParameter called, expected none")
	}
}

// FuncParameterCalledOnce returns true if FakeFuncer.FuncParameter was called exactly once
func (f *FakeFuncer) FuncParameterCalledOnce() bool {
	return len(f.FuncParameterCalls) == 1
}

// AssertFuncParameterCalledOnce calls t.Error if FakeFuncer.FuncParameter was not called exactly once
func (f *FakeFuncer) AssertFuncParameterCalledOnce(t FuncerTestingT) {
	t.Helper()
	if len(f.FuncParameterCalls) != 1 {
		t.Errorf("FakeFuncer.FuncParameter called %d times, expected 1", len(f.FuncParameterCalls))
	}
}

// FuncParameterCalledN returns true if FakeFuncer.FuncParameter was called at least n times
func (f *FakeFuncer) FuncParameterCalledN(n int) bool {
	return len(f.FuncParameterCalls) >= n
}

// AssertFuncParameterCalledN calls t.Error if FakeFuncer.FuncParameter was called less than n times
func (f *FakeFuncer) AssertFuncParameterCalledN(t FuncerTestingT, n int) {
	t.Helper()
	if len(f.FuncParameterCalls) < n {
		t.Errorf("FakeFuncer.FuncParameter called %d times, expected >= %d", len(f.FuncParameterCalls), n)
	}
}

// FuncParameterCalledWith returns true if FakeFuncer.FuncParameter was called with the given values
func (f_sym4 *FakeFuncer) FuncParameterCalledWith(ident1 func(string) string) bool {
	for _, call_sym4 := range f_sym4.FuncParameterCalls {
		if reflect.DeepEqual(call_sym4.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertFuncParameterCalledWith calls t.Error if FakeFuncer.FuncParameter was not called with the given values
func (f_sym5 *FakeFuncer) AssertFuncParameterCalledWith(t FuncerTestingT, ident1 func(string) string) {
	t.Helper()
	var found_sym5 bool
	for _, call_sym5 := range f_sym5.FuncParameterCalls {
		if reflect.DeepEqual(call_sym5.Parameters.Ident1, ident1) {
			found_sym5 = true
			break
		}
	}

	if !found_sym5 {
		t.Error("FakeFuncer.FuncParameter not called with expected parameters")
	}
}

// FuncParameterCalledOnceWith returns true if FakeFuncer.FuncParameter was called exactly once with the given values
func (f_sym6 *FakeFuncer) FuncParameterCalledOnceWith(ident1 func(string) string) bool {
	var count_sym6 int
	for _, call_sym6 := range f_sym6.FuncParameterCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Ident1, ident1) {
			count_sym6++
		}
	}

	return count_sym6 == 1
}

// AssertFuncParameterCalledOnceWith calls t.Error if FakeFuncer.FuncParameter was not called exactly once with the given values
func (f_sym7 *FakeFuncer) AssertFuncParameterCalledOnceWith(t FuncerTestingT, ident1 func(string) string) {
	t.Helper()
	var count_sym7 int
	for _, call_sym7 := range f_sym7.FuncParameterCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Ident1, ident1) {
			count_sym7++
		}
	}

	if count_sym7 != 1 {
		t.Errorf("FakeFuncer.FuncParameter called %d times with expected parameters, expected one", count_sym7)
	}
}

func (f_sym8 *FakeFuncer) FuncReturn() (ident1 func(string) string) {
	if f_sym8.FuncReturnHook == nil {
		panic("Funcer.FuncReturn() called but FakeFuncer.FuncReturnHook is nil")
	}

	invocation_sym8 := new(FuncerFuncReturnInvocation)
	f_sym8.FuncReturnCalls = append(f_sym8.FuncReturnCalls, invocation_sym8)

	ident1 = f_sym8.FuncReturnHook()

	invocation_sym8.Results.Ident1 = ident1

	return
}

// SetFuncReturnStub configures Funcer.FuncReturn to always return the given values
func (f_sym9 *FakeFuncer) SetFuncReturnStub(ident1 func(string) string) {
	f_sym9.FuncReturnHook = func() func(string) string {
		return ident1
	}
}

// FuncReturnCalled returns true if FakeFuncer.FuncReturn was called
func (f *FakeFuncer) FuncReturnCalled() bool {
	return len(f.FuncReturnCalls) != 0
}

// AssertFuncReturnCalled calls t.Error if FakeFuncer.FuncReturn was not called
func (f *FakeFuncer) AssertFuncReturnCalled(t FuncerTestingT) {
	t.Helper()
	if len(f.FuncReturnCalls) == 0 {
		t.Error("FakeFuncer.FuncReturn not called, expected at least one")
	}
}

// FuncReturnNotCalled returns true if FakeFuncer.FuncReturn was not called
func (f *FakeFuncer) FuncReturnNotCalled() bool {
	return len(f.FuncReturnCalls) == 0
}

// AssertFuncReturnNotCalled calls t.Error if FakeFuncer.FuncReturn was called
func (f *FakeFuncer) AssertFuncReturnNotCalled(t FuncerTestingT) {
	t.Helper()
	if len(f.FuncReturnCalls) != 0 {
		t.Error("FakeFuncer.FuncReturn called, expected none")
	}
}

// FuncReturnCalledOnce returns true if FakeFuncer.FuncReturn was called exactly once
func (f *FakeFuncer) FuncReturnCalledOnce() bool {
	return len(f.FuncReturnCalls) == 1
}

// AssertFuncReturnCalledOnce calls t.Error if FakeFuncer.FuncReturn was not called exactly once
func (f *FakeFuncer) AssertFuncReturnCalledOnce(t FuncerTestingT) {
	t.Helper()
	if len(f.FuncReturnCalls) != 1 {
		t.Errorf("FakeFuncer.FuncReturn called %d times, expected 1", len(f.FuncReturnCalls))
	}
}

// FuncReturnCalledN returns true if FakeFuncer.FuncReturn was called at least n times
func (f *FakeFuncer) FuncReturnCalledN(n int) bool {
	return len(f.FuncReturnCalls) >= n
}

// AssertFuncReturnCalledN calls t.Error if FakeFuncer.FuncReturn was called less than n times
func (f *FakeFuncer) AssertFuncReturnCalledN(t FuncerTestingT, n int) {
	t.Helper()
	if len(f.FuncReturnCalls) < n {
		t.Errorf("FakeFuncer.FuncReturn called %d times, expected >= %d", len(f.FuncReturnCalls), n)
	}
}
