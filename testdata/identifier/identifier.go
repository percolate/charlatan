// generated by "charlatan -dir=testdata/identifier -output=testdata/identifier/identifier.go Identifier".  DO NOT EDIT.

package main

import "reflect"

// IdentifierTestConstructorInvocation represents a single call of FakeIdentifier.TestConstructor
type IdentifierTestConstructorInvocation struct {
	Parameters struct {
		Val int64
	}
	Results struct {
		T string
	}
}

// NewIdentifierTestConstructorInvocation creates a new instance of IdentifierTestConstructorInvocation
func NewIdentifierTestConstructorInvocation(val int64, t string) *IdentifierTestConstructorInvocation {
	invocation := new(IdentifierTestConstructorInvocation)

	invocation.Parameters.Val = val

	invocation.Results.T = t

	return invocation
}

// IdentifierInvocationSetterInvocation represents a single call of FakeIdentifier.InvocationSetter
type IdentifierInvocationSetterInvocation struct {
	Parameters struct {
		Val int64
	}
	Results struct {
		Call     string
		Calls    string
		Fallback string
	}
}

// NewIdentifierInvocationSetterInvocation creates a new instance of IdentifierInvocationSetterInvocation
func NewIdentifierInvocationSetterInvocation(val int64, call string, calls string, fallback string) *IdentifierInvocationSetterInvocation {
	invocation := new(IdentifierInvocationSetterInvocation)

	invocation.Parameters.Val = val

	invocation.Results.Call = call
	invocation.Results.Calls = calls
	invocation.Results.Fallback = fallback

	return invocation
}

// IdentifierTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type IdentifierTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeIdentifier is a mock implementation of Identifier for testing.
Use it in your tests as in this example:

	package example

	func TestWithIdentifier(t *testing.T) {
		f := &main.FakeIdentifier{
			TestConstructorHook: func(val int64) (t string) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeTestConstructor ...
		f.AssertTestConstructorCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeTestConstructor.
*/
type FakeIdentifier struct {
	TestConstructorHook  func(int64) string
	InvocationSetterHook func(int64) (string, string, string)

	TestConstructorCalls  []*IdentifierTestConstructorInvocation
	InvocationSetterCalls []*IdentifierInvocationSetterInvocation
}

// NewFakeIdentifierDefaultPanic returns an instance of FakeIdentifier with all hooks configured to panic
func NewFakeIdentifierDefaultPanic() *FakeIdentifier {
	return &FakeIdentifier{
		TestConstructorHook: func(int64) (t string) {
			panic("Unexpected call to Identifier.TestConstructor")
		},
		InvocationSetterHook: func(int64) (call string, calls string, fallback string) {
			panic("Unexpected call to Identifier.InvocationSetter")
		},
	}
}

// NewFakeIdentifierDefaultFatal returns an instance of FakeIdentifier with all hooks configured to call t.Fatal
func NewFakeIdentifierDefaultFatal(t_sym1 IdentifierTestingT) *FakeIdentifier {
	return &FakeIdentifier{
		TestConstructorHook: func(int64) (t string) {
			t_sym1.Fatal("Unexpected call to Identifier.TestConstructor")
			return
		},
		InvocationSetterHook: func(int64) (call string, calls string, fallback string) {
			t_sym1.Fatal("Unexpected call to Identifier.InvocationSetter")
			return
		},
	}
}

// NewFakeIdentifierDefaultError returns an instance of FakeIdentifier with all hooks configured to call t.Error
func NewFakeIdentifierDefaultError(t_sym2 IdentifierTestingT) *FakeIdentifier {
	return &FakeIdentifier{
		TestConstructorHook: func(int64) (t string) {
			t_sym2.Error("Unexpected call to Identifier.TestConstructor")
			return
		},
		InvocationSetterHook: func(int64) (call string, calls string, fallback string) {
			t_sym2.Error("Unexpected call to Identifier.InvocationSetter")
			return
		},
	}
}

func (f *FakeIdentifier) Reset() {
	f.TestConstructorCalls = []*IdentifierTestConstructorInvocation{}
	f.InvocationSetterCalls = []*IdentifierInvocationSetterInvocation{}
}

func (f_sym3 *FakeIdentifier) TestConstructor(val int64) (t string) {
	if f_sym3.TestConstructorHook == nil {
		panic("Identifier.TestConstructor() called but FakeIdentifier.TestConstructorHook is nil")
	}

	invocation_sym3 := new(IdentifierTestConstructorInvocation)
	f_sym3.TestConstructorCalls = append(f_sym3.TestConstructorCalls, invocation_sym3)

	invocation_sym3.Parameters.Val = val

	t = f_sym3.TestConstructorHook(val)

	invocation_sym3.Results.T = t

	return
}

// SetTestConstructorStub configures Identifier.TestConstructor to always return the given values
func (f_sym4 *FakeIdentifier) SetTestConstructorStub(t string) {
	f_sym4.TestConstructorHook = func(int64) string {
		return t
	}
}

// SetTestConstructorInvocation configures Identifier.TestConstructor to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym5 *FakeIdentifier) SetTestConstructorInvocation(calls_sym5 []*IdentifierTestConstructorInvocation, fallback_sym5 func() string) {
	f_sym5.TestConstructorHook = func(val int64) (t string) {
		for _, call_sym5 := range calls_sym5 {
			if reflect.DeepEqual(call_sym5.Parameters.Val, val) {
				t = call_sym5.Results.T

				return
			}
		}

		return fallback_sym5()
	}
}

// TestConstructorCalled returns true if FakeIdentifier.TestConstructor was called
func (f *FakeIdentifier) TestConstructorCalled() bool {
	return len(f.TestConstructorCalls) != 0
}

// AssertTestConstructorCalled calls t.Error if FakeIdentifier.TestConstructor was not called
func (f *FakeIdentifier) AssertTestConstructorCalled(t IdentifierTestingT) {
	t.Helper()
	if len(f.TestConstructorCalls) == 0 {
		t.Error("FakeIdentifier.TestConstructor not called, expected at least one")
	}
}

// TestConstructorNotCalled returns true if FakeIdentifier.TestConstructor was not called
func (f *FakeIdentifier) TestConstructorNotCalled() bool {
	return len(f.TestConstructorCalls) == 0
}

// AssertTestConstructorNotCalled calls t.Error if FakeIdentifier.TestConstructor was called
func (f *FakeIdentifier) AssertTestConstructorNotCalled(t IdentifierTestingT) {
	t.Helper()
	if len(f.TestConstructorCalls) != 0 {
		t.Error("FakeIdentifier.TestConstructor called, expected none")
	}
}

// TestConstructorCalledOnce returns true if FakeIdentifier.TestConstructor was called exactly once
func (f *FakeIdentifier) TestConstructorCalledOnce() bool {
	return len(f.TestConstructorCalls) == 1
}

// AssertTestConstructorCalledOnce calls t.Error if FakeIdentifier.TestConstructor was not called exactly once
func (f *FakeIdentifier) AssertTestConstructorCalledOnce(t IdentifierTestingT) {
	t.Helper()
	if len(f.TestConstructorCalls) != 1 {
		t.Errorf("FakeIdentifier.TestConstructor called %d times, expected 1", len(f.TestConstructorCalls))
	}
}

// TestConstructorCalledN returns true if FakeIdentifier.TestConstructor was called at least n times
func (f *FakeIdentifier) TestConstructorCalledN(n int) bool {
	return len(f.TestConstructorCalls) >= n
}

// AssertTestConstructorCalledN calls t.Error if FakeIdentifier.TestConstructor was called less than n times
func (f *FakeIdentifier) AssertTestConstructorCalledN(t IdentifierTestingT, n int) {
	t.Helper()
	if len(f.TestConstructorCalls) < n {
		t.Errorf("FakeIdentifier.TestConstructor called %d times, expected >= %d", len(f.TestConstructorCalls), n)
	}
}

// TestConstructorCalledWith returns true if FakeIdentifier.TestConstructor was called with the given values
func (f_sym6 *FakeIdentifier) TestConstructorCalledWith(val int64) bool {
	for _, call_sym6 := range f_sym6.TestConstructorCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Val, val) {
			return true
		}
	}

	return false
}

// AssertTestConstructorCalledWith calls t.Error if FakeIdentifier.TestConstructor was not called with the given values
func (f_sym7 *FakeIdentifier) AssertTestConstructorCalledWith(t IdentifierTestingT, val int64) {
	t.Helper()
	var found_sym7 bool
	for _, call_sym7 := range f_sym7.TestConstructorCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Val, val) {
			found_sym7 = true
			break
		}
	}

	if !found_sym7 {
		t.Error("FakeIdentifier.TestConstructor not called with expected parameters")
	}
}

// TestConstructorCalledOnceWith returns true if FakeIdentifier.TestConstructor was called exactly once with the given values
func (f_sym8 *FakeIdentifier) TestConstructorCalledOnceWith(val int64) bool {
	var count_sym8 int
	for _, call_sym8 := range f_sym8.TestConstructorCalls {
		if reflect.DeepEqual(call_sym8.Parameters.Val, val) {
			count_sym8++
		}
	}

	return count_sym8 == 1
}

// AssertTestConstructorCalledOnceWith calls t.Error if FakeIdentifier.TestConstructor was not called exactly once with the given values
func (f_sym9 *FakeIdentifier) AssertTestConstructorCalledOnceWith(t IdentifierTestingT, val int64) {
	t.Helper()
	var count_sym9 int
	for _, call_sym9 := range f_sym9.TestConstructorCalls {
		if reflect.DeepEqual(call_sym9.Parameters.Val, val) {
			count_sym9++
		}
	}

	if count_sym9 != 1 {
		t.Errorf("FakeIdentifier.TestConstructor called %d times with expected parameters, expected one", count_sym9)
	}
}

// TestConstructorResultsForCall returns the result values for the first call to FakeIdentifier.TestConstructor with the given values
func (f_sym10 *FakeIdentifier) TestConstructorResultsForCall(val int64) (t string, found_sym10 bool) {
	for _, call_sym10 := range f_sym10.TestConstructorCalls {
		if reflect.DeepEqual(call_sym10.Parameters.Val, val) {
			t = call_sym10.Results.T
			found_sym10 = true
			break
		}
	}

	return
}

func (f_sym11 *FakeIdentifier) InvocationSetter(val int64) (call string, calls string, fallback string) {
	if f_sym11.InvocationSetterHook == nil {
		panic("Identifier.InvocationSetter() called but FakeIdentifier.InvocationSetterHook is nil")
	}

	invocation_sym11 := new(IdentifierInvocationSetterInvocation)
	f_sym11.InvocationSetterCalls = append(f_sym11.InvocationSetterCalls, invocation_sym11)

	invocation_sym11.Parameters.Val = val

	call, calls, fallback = f_sym11.InvocationSetterHook(val)

	invocation_sym11.Results.Call = call
	invocation_sym11.Results.Calls = calls
	invocation_sym11.Results.Fallback = fallback

	return
}

// SetInvocationSetterStub configures Identifier.InvocationSetter to always return the given values
func (f_sym12 *FakeIdentifier) SetInvocationSetterStub(call string, calls string, fallback string) {
	f_sym12.InvocationSetterHook = func(int64) (string, string, string) {
		return call, calls, fallback
	}
}

// SetInvocationSetterInvocation configures Identifier.InvocationSetter to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym13 *FakeIdentifier) SetInvocationSetterInvocation(calls_sym13 []*IdentifierInvocationSetterInvocation, fallback_sym13 func() (string, string, string)) {
	f_sym13.InvocationSetterHook = func(val int64) (call string, calls string, fallback string) {
		for _, call_sym13 := range calls_sym13 {
			if reflect.DeepEqual(call_sym13.Parameters.Val, val) {
				call = call_sym13.Results.Call
				calls = call_sym13.Results.Calls
				fallback = call_sym13.Results.Fallback

				return
			}
		}

		return fallback_sym13()
	}
}

// InvocationSetterCalled returns true if FakeIdentifier.InvocationSetter was called
func (f *FakeIdentifier) InvocationSetterCalled() bool {
	return len(f.InvocationSetterCalls) != 0
}

// AssertInvocationSetterCalled calls t.Error if FakeIdentifier.InvocationSetter was not called
func (f *FakeIdentifier) AssertInvocationSetterCalled(t IdentifierTestingT) {
	t.Helper()
	if len(f.InvocationSetterCalls) == 0 {
		t.Error("FakeIdentifier.InvocationSetter not called, expected at least one")
	}
}

// InvocationSetterNotCalled returns true if FakeIdentifier.InvocationSetter was not called
func (f *FakeIdentifier) InvocationSetterNotCalled() bool {
	return len(f.InvocationSetterCalls) == 0
}

// AssertInvocationSetterNotCalled calls t.Error if FakeIdentifier.InvocationSetter was called
func (f *FakeIdentifier) AssertInvocationSetterNotCalled(t IdentifierTestingT) {
	t.Helper()
	if len(f.InvocationSetterCalls) != 0 {
		t.Error("FakeIdentifier.InvocationSetter called, expected none")
	}
}

// InvocationSetterCalledOnce returns true if FakeIdentifier.InvocationSetter was called exactly once
func (f *FakeIdentifier) InvocationSetterCalledOnce() bool {
	return len(f.InvocationSetterCalls) == 1
}

// AssertInvocationSetterCalledOnce calls t.Error if FakeIdentifier.InvocationSetter was not called exactly once
func (f *FakeIdentifier) AssertInvocationSetterCalledOnce(t IdentifierTestingT) {
	t.Helper()
	if len(f.InvocationSetterCalls) != 1 {
		t.Errorf("FakeIdentifier.InvocationSetter called %d times, expected 1", len(f.InvocationSetterCalls))
	}
}

// InvocationSetterCalledN returns true if FakeIdentifier.InvocationSetter was called at least n times
func (f *FakeIdentifier) InvocationSetterCalledN(n int) bool {
	return len(f.InvocationSetterCalls) >= n
}

// AssertInvocationSetterCalledN calls t.Error if FakeIdentifier.InvocationSetter was called less than n times
func (f *FakeIdentifier) AssertInvocationSetterCalledN(t IdentifierTestingT, n int) {
	t.Helper()
	if len(f.InvocationSetterCalls) < n {
		t.Errorf("FakeIdentifier.InvocationSetter called %d times, expected >= %d", len(f.InvocationSetterCalls), n)
	}
}

// InvocationSetterCalledWith returns true if FakeIdentifier.InvocationSetter was called with the given values
func (f_sym14 *FakeIdentifier) InvocationSetterCalledWith(val int64) bool {
	for _, call_sym14 := range f_sym14.InvocationSetterCalls {
		if reflect.DeepEqual(call_sym14.Parameters.Val, val) {
			return true
		}
	}

	return false
}

// AssertInvocationSetterCalledWith calls t.Error if FakeIdentifier.InvocationSetter was not called with the given values
func (f_sym15 *FakeIdentifier) AssertInvocationSetterCalledWith(t IdentifierTestingT, val int64) {
	t.Helper()
	var found_sym15 bool
	for _, call_sym15 := range f_sym15.InvocationSetterCalls {
		if reflect.DeepEqual(call_sym15.Parameters.Val, val) {
			found_sym15 = true
			break
		}
	}

	if !found_sym15 {
		t.Error("FakeIdentifier.InvocationSetter not called with expected parameters")
	}
}

// InvocationSetterCalledOnceWith returns true if FakeIdentifier.InvocationSetter was called exactly once with the given values
func (f_sym16 *FakeIdentifier) InvocationSetterCalledOnceWith(val int64) bool {
	var count_sym16 int
	for _, call_sym16 := range f_sym16.InvocationSetterCalls {
		if reflect.DeepEqual(call_sym16.Parameters.Val, val) {
			count_sym16++
		}
	}

	return count_sym16 == 1
}

// AssertInvocationSetterCalledOnceWith calls t.Error if FakeIdentifier.InvocationSetter was not called exactly once with the given values
func (f_sym17 *FakeIdentifier) AssertInvocationSetterCalledOnceWith(t IdentifierTestingT, val int64) {
	t.Helper()
	var count_sym17 int
	for _, call_sym17 := range f_sym17.InvocationSetterCalls {
		if reflect.DeepEqual(call_sym17.Parameters.Val, val) {
			count_sym17++
		}
	}

	if count_sym17 != 1 {
		t.Errorf("FakeIdentifier.InvocationSetter called %d times with expected parameters, expected one", count_sym17)
	}
}

// InvocationSetterResultsForCall returns the result values for the first call to FakeIdentifier.InvocationSetter with the given values
func (f_sym18 *FakeIdentifier) InvocationSetterResultsForCall(val int64) (call string, calls string, fallback string, found_sym18 bool) {
	for _, call_sym18 := range f_sym18.InvocationSetterCalls {
		if reflect.DeepEqual(call_sym18.Parameters.Val, val) {
			call = call_sym18.Results.Call
			calls = call_sym18.Results.Calls
			fallback = call_sym18.Results.Fallback
			found_sym18 = true
			break
		}
	}

	return
}
