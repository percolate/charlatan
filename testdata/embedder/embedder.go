// generated by "charlatan -dir=testdata/embedder -output=testdata/embedder/embedder.go Embedder".  DO NOT EDIT.

package main

import "reflect"

// EmbedderStringInvocation represents a single call of FakeEmbedder.String
type EmbedderStringInvocation struct {
	Results struct {
		Ident5 string
	}
}

// EmbedderEmbedInvocation represents a single call of FakeEmbedder.Embed
type EmbedderEmbedInvocation struct {
	Parameters struct {
		Ident1 string
	}
	Results struct {
		Ident2 string
	}
}

// NewEmbedderEmbedInvocation creates a new instance of EmbedderEmbedInvocation
func NewEmbedderEmbedInvocation(ident1 string, ident2 string) *EmbedderEmbedInvocation {
	invocation := new(EmbedderEmbedInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// EmbedderOtherInvocation represents a single call of FakeEmbedder.Other
type EmbedderOtherInvocation struct {
	Parameters struct {
		Ident1 string
	}
	Results struct {
		Ident2 string
	}
}

// NewEmbedderOtherInvocation creates a new instance of EmbedderOtherInvocation
func NewEmbedderOtherInvocation(ident1 string, ident2 string) *EmbedderOtherInvocation {
	invocation := new(EmbedderOtherInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// EmbedderTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type EmbedderTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeEmbedder is a mock implementation of Embedder for testing.
Use it in your tests as in this example:

	package example

	func TestWithEmbedder(t *testing.T) {
		f := &main.FakeEmbedder{
			StringHook: func() (ident5 string) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeString ...
		f.AssertStringCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeString.
*/
type FakeEmbedder struct {
	StringHook func() string
	EmbedHook  func(string) string
	OtherHook  func(string) string

	StringCalls []*EmbedderStringInvocation
	EmbedCalls  []*EmbedderEmbedInvocation
	OtherCalls  []*EmbedderOtherInvocation
}

// NewFakeEmbedderDefaultPanic returns an instance of FakeEmbedder with all hooks configured to panic
func NewFakeEmbedderDefaultPanic() *FakeEmbedder {
	return &FakeEmbedder{
		StringHook: func() (ident5 string) {
			panic("Unexpected call to Embedder.String")
		},
		EmbedHook: func(string) (ident2 string) {
			panic("Unexpected call to Embedder.Embed")
		},
		OtherHook: func(string) (ident2 string) {
			panic("Unexpected call to Embedder.Other")
		},
	}
}

// NewFakeEmbedderDefaultFatal returns an instance of FakeEmbedder with all hooks configured to call t.Fatal
func NewFakeEmbedderDefaultFatal(t_sym1 EmbedderTestingT) *FakeEmbedder {
	return &FakeEmbedder{
		StringHook: func() (ident5 string) {
			t_sym1.Fatal("Unexpected call to Embedder.String")
			return
		},
		EmbedHook: func(string) (ident2 string) {
			t_sym1.Fatal("Unexpected call to Embedder.Embed")
			return
		},
		OtherHook: func(string) (ident2 string) {
			t_sym1.Fatal("Unexpected call to Embedder.Other")
			return
		},
	}
}

// NewFakeEmbedderDefaultError returns an instance of FakeEmbedder with all hooks configured to call t.Error
func NewFakeEmbedderDefaultError(t_sym2 EmbedderTestingT) *FakeEmbedder {
	return &FakeEmbedder{
		StringHook: func() (ident5 string) {
			t_sym2.Error("Unexpected call to Embedder.String")
			return
		},
		EmbedHook: func(string) (ident2 string) {
			t_sym2.Error("Unexpected call to Embedder.Embed")
			return
		},
		OtherHook: func(string) (ident2 string) {
			t_sym2.Error("Unexpected call to Embedder.Other")
			return
		},
	}
}

func (f *FakeEmbedder) Reset() {
	f.StringCalls = []*EmbedderStringInvocation{}
	f.EmbedCalls = []*EmbedderEmbedInvocation{}
	f.OtherCalls = []*EmbedderOtherInvocation{}
}

func (f_sym3 *FakeEmbedder) String() (ident5 string) {
	if f_sym3.StringHook == nil {
		panic("Embedder.String() called but FakeEmbedder.StringHook is nil")
	}

	invocation_sym3 := new(EmbedderStringInvocation)
	f_sym3.StringCalls = append(f_sym3.StringCalls, invocation_sym3)

	ident5 = f_sym3.StringHook()

	invocation_sym3.Results.Ident5 = ident5

	return
}

// SetStringStub configures Embedder.String to always return the given values
func (f_sym4 *FakeEmbedder) SetStringStub(ident5 string) {
	f_sym4.StringHook = func() string {
		return ident5
	}
}

// StringCalled returns true if FakeEmbedder.String was called
func (f *FakeEmbedder) StringCalled() bool {
	return len(f.StringCalls) != 0
}

// AssertStringCalled calls t.Error if FakeEmbedder.String was not called
func (f *FakeEmbedder) AssertStringCalled(t EmbedderTestingT) {
	t.Helper()
	if len(f.StringCalls) == 0 {
		t.Error("FakeEmbedder.String not called, expected at least one")
	}
}

// StringNotCalled returns true if FakeEmbedder.String was not called
func (f *FakeEmbedder) StringNotCalled() bool {
	return len(f.StringCalls) == 0
}

// AssertStringNotCalled calls t.Error if FakeEmbedder.String was called
func (f *FakeEmbedder) AssertStringNotCalled(t EmbedderTestingT) {
	t.Helper()
	if len(f.StringCalls) != 0 {
		t.Error("FakeEmbedder.String called, expected none")
	}
}

// StringCalledOnce returns true if FakeEmbedder.String was called exactly once
func (f *FakeEmbedder) StringCalledOnce() bool {
	return len(f.StringCalls) == 1
}

// AssertStringCalledOnce calls t.Error if FakeEmbedder.String was not called exactly once
func (f *FakeEmbedder) AssertStringCalledOnce(t EmbedderTestingT) {
	t.Helper()
	if len(f.StringCalls) != 1 {
		t.Errorf("FakeEmbedder.String called %d times, expected 1", len(f.StringCalls))
	}
}

// StringCalledN returns true if FakeEmbedder.String was called at least n times
func (f *FakeEmbedder) StringCalledN(n int) bool {
	return len(f.StringCalls) >= n
}

// AssertStringCalledN calls t.Error if FakeEmbedder.String was called less than n times
func (f *FakeEmbedder) AssertStringCalledN(t EmbedderTestingT, n int) {
	t.Helper()
	if len(f.StringCalls) < n {
		t.Errorf("FakeEmbedder.String called %d times, expected >= %d", len(f.StringCalls), n)
	}
}

func (f_sym5 *FakeEmbedder) Embed(ident1 string) (ident2 string) {
	if f_sym5.EmbedHook == nil {
		panic("Embedder.Embed() called but FakeEmbedder.EmbedHook is nil")
	}

	invocation_sym5 := new(EmbedderEmbedInvocation)
	f_sym5.EmbedCalls = append(f_sym5.EmbedCalls, invocation_sym5)

	invocation_sym5.Parameters.Ident1 = ident1

	ident2 = f_sym5.EmbedHook(ident1)

	invocation_sym5.Results.Ident2 = ident2

	return
}

// SetEmbedStub configures Embedder.Embed to always return the given values
func (f_sym6 *FakeEmbedder) SetEmbedStub(ident2 string) {
	f_sym6.EmbedHook = func(string) string {
		return ident2
	}
}

// SetEmbedInvocation configures Embedder.Embed to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym7 *FakeEmbedder) SetEmbedInvocation(calls_sym7 []*EmbedderEmbedInvocation, fallback_sym7 func() string) {
	f_sym7.EmbedHook = func(ident1 string) (ident2 string) {
		for _, call_sym7 := range calls_sym7 {
			if reflect.DeepEqual(call_sym7.Parameters.Ident1, ident1) {
				ident2 = call_sym7.Results.Ident2

				return
			}
		}

		return fallback_sym7()
	}
}

// EmbedCalled returns true if FakeEmbedder.Embed was called
func (f *FakeEmbedder) EmbedCalled() bool {
	return len(f.EmbedCalls) != 0
}

// AssertEmbedCalled calls t.Error if FakeEmbedder.Embed was not called
func (f *FakeEmbedder) AssertEmbedCalled(t EmbedderTestingT) {
	t.Helper()
	if len(f.EmbedCalls) == 0 {
		t.Error("FakeEmbedder.Embed not called, expected at least one")
	}
}

// EmbedNotCalled returns true if FakeEmbedder.Embed was not called
func (f *FakeEmbedder) EmbedNotCalled() bool {
	return len(f.EmbedCalls) == 0
}

// AssertEmbedNotCalled calls t.Error if FakeEmbedder.Embed was called
func (f *FakeEmbedder) AssertEmbedNotCalled(t EmbedderTestingT) {
	t.Helper()
	if len(f.EmbedCalls) != 0 {
		t.Error("FakeEmbedder.Embed called, expected none")
	}
}

// EmbedCalledOnce returns true if FakeEmbedder.Embed was called exactly once
func (f *FakeEmbedder) EmbedCalledOnce() bool {
	return len(f.EmbedCalls) == 1
}

// AssertEmbedCalledOnce calls t.Error if FakeEmbedder.Embed was not called exactly once
func (f *FakeEmbedder) AssertEmbedCalledOnce(t EmbedderTestingT) {
	t.Helper()
	if len(f.EmbedCalls) != 1 {
		t.Errorf("FakeEmbedder.Embed called %d times, expected 1", len(f.EmbedCalls))
	}
}

// EmbedCalledN returns true if FakeEmbedder.Embed was called at least n times
func (f *FakeEmbedder) EmbedCalledN(n int) bool {
	return len(f.EmbedCalls) >= n
}

// AssertEmbedCalledN calls t.Error if FakeEmbedder.Embed was called less than n times
func (f *FakeEmbedder) AssertEmbedCalledN(t EmbedderTestingT, n int) {
	t.Helper()
	if len(f.EmbedCalls) < n {
		t.Errorf("FakeEmbedder.Embed called %d times, expected >= %d", len(f.EmbedCalls), n)
	}
}

// EmbedCalledWith returns true if FakeEmbedder.Embed was called with the given values
func (f_sym8 *FakeEmbedder) EmbedCalledWith(ident1 string) bool {
	for _, call_sym8 := range f_sym8.EmbedCalls {
		if reflect.DeepEqual(call_sym8.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertEmbedCalledWith calls t.Error if FakeEmbedder.Embed was not called with the given values
func (f_sym9 *FakeEmbedder) AssertEmbedCalledWith(t EmbedderTestingT, ident1 string) {
	t.Helper()
	var found_sym9 bool
	for _, call_sym9 := range f_sym9.EmbedCalls {
		if reflect.DeepEqual(call_sym9.Parameters.Ident1, ident1) {
			found_sym9 = true
			break
		}
	}

	if !found_sym9 {
		t.Error("FakeEmbedder.Embed not called with expected parameters")
	}
}

// EmbedCalledOnceWith returns true if FakeEmbedder.Embed was called exactly once with the given values
func (f_sym10 *FakeEmbedder) EmbedCalledOnceWith(ident1 string) bool {
	var count_sym10 int
	for _, call_sym10 := range f_sym10.EmbedCalls {
		if reflect.DeepEqual(call_sym10.Parameters.Ident1, ident1) {
			count_sym10++
		}
	}

	return count_sym10 == 1
}

// AssertEmbedCalledOnceWith calls t.Error if FakeEmbedder.Embed was not called exactly once with the given values
func (f_sym11 *FakeEmbedder) AssertEmbedCalledOnceWith(t EmbedderTestingT, ident1 string) {
	t.Helper()
	var count_sym11 int
	for _, call_sym11 := range f_sym11.EmbedCalls {
		if reflect.DeepEqual(call_sym11.Parameters.Ident1, ident1) {
			count_sym11++
		}
	}

	if count_sym11 != 1 {
		t.Errorf("FakeEmbedder.Embed called %d times with expected parameters, expected one", count_sym11)
	}
}

// EmbedResultsForCall returns the result values for the first call to FakeEmbedder.Embed with the given values
func (f_sym12 *FakeEmbedder) EmbedResultsForCall(ident1 string) (ident2 string, found_sym12 bool) {
	for _, call_sym12 := range f_sym12.EmbedCalls {
		if reflect.DeepEqual(call_sym12.Parameters.Ident1, ident1) {
			ident2 = call_sym12.Results.Ident2
			found_sym12 = true
			break
		}
	}

	return
}

func (f_sym13 *FakeEmbedder) Other(ident1 string) (ident2 string) {
	if f_sym13.OtherHook == nil {
		panic("Embedder.Other() called but FakeEmbedder.OtherHook is nil")
	}

	invocation_sym13 := new(EmbedderOtherInvocation)
	f_sym13.OtherCalls = append(f_sym13.OtherCalls, invocation_sym13)

	invocation_sym13.Parameters.Ident1 = ident1

	ident2 = f_sym13.OtherHook(ident1)

	invocation_sym13.Results.Ident2 = ident2

	return
}

// SetOtherStub configures Embedder.Other to always return the given values
func (f_sym14 *FakeEmbedder) SetOtherStub(ident2 string) {
	f_sym14.OtherHook = func(string) string {
		return ident2
	}
}

// SetOtherInvocation configures Embedder.Other to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym15 *FakeEmbedder) SetOtherInvocation(calls_sym15 []*EmbedderOtherInvocation, fallback_sym15 func() string) {
	f_sym15.OtherHook = func(ident1 string) (ident2 string) {
		for _, call_sym15 := range calls_sym15 {
			if reflect.DeepEqual(call_sym15.Parameters.Ident1, ident1) {
				ident2 = call_sym15.Results.Ident2

				return
			}
		}

		return fallback_sym15()
	}
}

// OtherCalled returns true if FakeEmbedder.Other was called
func (f *FakeEmbedder) OtherCalled() bool {
	return len(f.OtherCalls) != 0
}

// AssertOtherCalled calls t.Error if FakeEmbedder.Other was not called
func (f *FakeEmbedder) AssertOtherCalled(t EmbedderTestingT) {
	t.Helper()
	if len(f.OtherCalls) == 0 {
		t.Error("FakeEmbedder.Other not called, expected at least one")
	}
}

// OtherNotCalled returns true if FakeEmbedder.Other was not called
func (f *FakeEmbedder) OtherNotCalled() bool {
	return len(f.OtherCalls) == 0
}

// AssertOtherNotCalled calls t.Error if FakeEmbedder.Other was called
func (f *FakeEmbedder) AssertOtherNotCalled(t EmbedderTestingT) {
	t.Helper()
	if len(f.OtherCalls) != 0 {
		t.Error("FakeEmbedder.Other called, expected none")
	}
}

// OtherCalledOnce returns true if FakeEmbedder.Other was called exactly once
func (f *FakeEmbedder) OtherCalledOnce() bool {
	return len(f.OtherCalls) == 1
}

// AssertOtherCalledOnce calls t.Error if FakeEmbedder.Other was not called exactly once
func (f *FakeEmbedder) AssertOtherCalledOnce(t EmbedderTestingT) {
	t.Helper()
	if len(f.OtherCalls) != 1 {
		t.Errorf("FakeEmbedder.Other called %d times, expected 1", len(f.OtherCalls))
	}
}

// OtherCalledN returns true if FakeEmbedder.Other was called at least n times
func (f *FakeEmbedder) OtherCalledN(n int) bool {
	return len(f.OtherCalls) >= n
}

// AssertOtherCalledN calls t.Error if FakeEmbedder.Other was called less than n times
func (f *FakeEmbedder) AssertOtherCalledN(t EmbedderTestingT, n int) {
	t.Helper()
	if len(f.OtherCalls) < n {
		t.Errorf("FakeEmbedder.Other called %d times, expected >= %d", len(f.OtherCalls), n)
	}
}

// OtherCalledWith returns true if FakeEmbedder.Other was called with the given values
func (f_sym16 *FakeEmbedder) OtherCalledWith(ident1 string) bool {
	for _, call_sym16 := range f_sym16.OtherCalls {
		if reflect.DeepEqual(call_sym16.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertOtherCalledWith calls t.Error if FakeEmbedder.Other was not called with the given values
func (f_sym17 *FakeEmbedder) AssertOtherCalledWith(t EmbedderTestingT, ident1 string) {
	t.Helper()
	var found_sym17 bool
	for _, call_sym17 := range f_sym17.OtherCalls {
		if reflect.DeepEqual(call_sym17.Parameters.Ident1, ident1) {
			found_sym17 = true
			break
		}
	}

	if !found_sym17 {
		t.Error("FakeEmbedder.Other not called with expected parameters")
	}
}

// OtherCalledOnceWith returns true if FakeEmbedder.Other was called exactly once with the given values
func (f_sym18 *FakeEmbedder) OtherCalledOnceWith(ident1 string) bool {
	var count_sym18 int
	for _, call_sym18 := range f_sym18.OtherCalls {
		if reflect.DeepEqual(call_sym18.Parameters.Ident1, ident1) {
			count_sym18++
		}
	}

	return count_sym18 == 1
}

// AssertOtherCalledOnceWith calls t.Error if FakeEmbedder.Other was not called exactly once with the given values
func (f_sym19 *FakeEmbedder) AssertOtherCalledOnceWith(t EmbedderTestingT, ident1 string) {
	t.Helper()
	var count_sym19 int
	for _, call_sym19 := range f_sym19.OtherCalls {
		if reflect.DeepEqual(call_sym19.Parameters.Ident1, ident1) {
			count_sym19++
		}
	}

	if count_sym19 != 1 {
		t.Errorf("FakeEmbedder.Other called %d times with expected parameters, expected one", count_sym19)
	}
}

// OtherResultsForCall returns the result values for the first call to FakeEmbedder.Other with the given values
func (f_sym20 *FakeEmbedder) OtherResultsForCall(ident1 string) (ident2 string, found_sym20 bool) {
	for _, call_sym20 := range f_sym20.OtherCalls {
		if reflect.DeepEqual(call_sym20.Parameters.Ident1, ident1) {
			ident2 = call_sym20.Results.Ident2
			found_sym20 = true
			break
		}
	}

	return
}
