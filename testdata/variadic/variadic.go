// generated by "charlatan -dir=testdata/variadic -output=testdata/variadic/variadic.go Variadic".  DO NOT EDIT.

package main

import "reflect"

// VariadicSingleVariadicInvocation represents a single call of FakeVariadic.SingleVariadic
type VariadicSingleVariadicInvocation struct {
	Parameters struct {
		A []string
	}
}

// VariadicMixedVariadicInvocation represents a single call of FakeVariadic.MixedVariadic
type VariadicMixedVariadicInvocation struct {
	Parameters struct {
		A int
		B int
		C int
		D []string
	}
}

// VariadicTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type VariadicTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeVariadic is a mock implementation of Variadic for testing.
Use it in your tests as in this example:

	package example

	func TestWithVariadic(t *testing.T) {
		f := &main.FakeVariadic{
			SingleVariadicHook: func(a ...string) () {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeSingleVariadic ...
		f.AssertSingleVariadicCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeSingleVariadic.
*/
type FakeVariadic struct {
	SingleVariadicHook func(...string)
	MixedVariadicHook  func(int, int, int, ...string)

	SingleVariadicCalls []*VariadicSingleVariadicInvocation
	MixedVariadicCalls  []*VariadicMixedVariadicInvocation
}

// NewFakeVariadicDefaultPanic returns an instance of FakeVariadic with all hooks configured to panic
func NewFakeVariadicDefaultPanic() *FakeVariadic {
	return &FakeVariadic{
		SingleVariadicHook: func(...string) {
			panic("Unexpected call to Variadic.SingleVariadic")
		},
		MixedVariadicHook: func(int, int, int, ...string) {
			panic("Unexpected call to Variadic.MixedVariadic")
		},
	}
}

// NewFakeVariadicDefaultFatal returns an instance of FakeVariadic with all hooks configured to call t.Fatal
func NewFakeVariadicDefaultFatal(t_sym1 VariadicTestingT) *FakeVariadic {
	return &FakeVariadic{
		SingleVariadicHook: func(...string) {
			t_sym1.Fatal("Unexpected call to Variadic.SingleVariadic")
			return
		},
		MixedVariadicHook: func(int, int, int, ...string) {
			t_sym1.Fatal("Unexpected call to Variadic.MixedVariadic")
			return
		},
	}
}

// NewFakeVariadicDefaultError returns an instance of FakeVariadic with all hooks configured to call t.Error
func NewFakeVariadicDefaultError(t_sym2 VariadicTestingT) *FakeVariadic {
	return &FakeVariadic{
		SingleVariadicHook: func(...string) {
			t_sym2.Error("Unexpected call to Variadic.SingleVariadic")
			return
		},
		MixedVariadicHook: func(int, int, int, ...string) {
			t_sym2.Error("Unexpected call to Variadic.MixedVariadic")
			return
		},
	}
}

func (f *FakeVariadic) Reset() {
	f.SingleVariadicCalls = []*VariadicSingleVariadicInvocation{}
	f.MixedVariadicCalls = []*VariadicMixedVariadicInvocation{}
}

func (f_sym3 *FakeVariadic) SingleVariadic(a ...string) {
	if f_sym3.SingleVariadicHook == nil {
		panic("Variadic.SingleVariadic() called but FakeVariadic.SingleVariadicHook is nil")
	}

	invocation_sym3 := new(VariadicSingleVariadicInvocation)
	f_sym3.SingleVariadicCalls = append(f_sym3.SingleVariadicCalls, invocation_sym3)

	invocation_sym3.Parameters.A = a

	f_sym3.SingleVariadicHook(a...)

	return
}

// SingleVariadicCalled returns true if FakeVariadic.SingleVariadic was called
func (f *FakeVariadic) SingleVariadicCalled() bool {
	return len(f.SingleVariadicCalls) != 0
}

// AssertSingleVariadicCalled calls t.Error if FakeVariadic.SingleVariadic was not called
func (f *FakeVariadic) AssertSingleVariadicCalled(t VariadicTestingT) {
	t.Helper()
	if len(f.SingleVariadicCalls) == 0 {
		t.Error("FakeVariadic.SingleVariadic not called, expected at least one")
	}
}

// SingleVariadicNotCalled returns true if FakeVariadic.SingleVariadic was not called
func (f *FakeVariadic) SingleVariadicNotCalled() bool {
	return len(f.SingleVariadicCalls) == 0
}

// AssertSingleVariadicNotCalled calls t.Error if FakeVariadic.SingleVariadic was called
func (f *FakeVariadic) AssertSingleVariadicNotCalled(t VariadicTestingT) {
	t.Helper()
	if len(f.SingleVariadicCalls) != 0 {
		t.Error("FakeVariadic.SingleVariadic called, expected none")
	}
}

// SingleVariadicCalledOnce returns true if FakeVariadic.SingleVariadic was called exactly once
func (f *FakeVariadic) SingleVariadicCalledOnce() bool {
	return len(f.SingleVariadicCalls) == 1
}

// AssertSingleVariadicCalledOnce calls t.Error if FakeVariadic.SingleVariadic was not called exactly once
func (f *FakeVariadic) AssertSingleVariadicCalledOnce(t VariadicTestingT) {
	t.Helper()
	if len(f.SingleVariadicCalls) != 1 {
		t.Errorf("FakeVariadic.SingleVariadic called %d times, expected 1", len(f.SingleVariadicCalls))
	}
}

// SingleVariadicCalledN returns true if FakeVariadic.SingleVariadic was called at least n times
func (f *FakeVariadic) SingleVariadicCalledN(n int) bool {
	return len(f.SingleVariadicCalls) >= n
}

// AssertSingleVariadicCalledN calls t.Error if FakeVariadic.SingleVariadic was called less than n times
func (f *FakeVariadic) AssertSingleVariadicCalledN(t VariadicTestingT, n int) {
	t.Helper()
	if len(f.SingleVariadicCalls) < n {
		t.Errorf("FakeVariadic.SingleVariadic called %d times, expected >= %d", len(f.SingleVariadicCalls), n)
	}
}

// SingleVariadicCalledWith returns true if FakeVariadic.SingleVariadic was called with the given values
func (f_sym4 *FakeVariadic) SingleVariadicCalledWith(a ...string) bool {
	for _, call_sym4 := range f_sym4.SingleVariadicCalls {
		if reflect.DeepEqual(call_sym4.Parameters.A, a) {
			return true
		}
	}

	return false
}

// AssertSingleVariadicCalledWith calls t.Error if FakeVariadic.SingleVariadic was not called with the given values
func (f_sym5 *FakeVariadic) AssertSingleVariadicCalledWith(t VariadicTestingT, a ...string) {
	t.Helper()
	var found_sym5 bool
	for _, call_sym5 := range f_sym5.SingleVariadicCalls {
		if reflect.DeepEqual(call_sym5.Parameters.A, a) {
			found_sym5 = true
			break
		}
	}

	if !found_sym5 {
		t.Error("FakeVariadic.SingleVariadic not called with expected parameters")
	}
}

// SingleVariadicCalledOnceWith returns true if FakeVariadic.SingleVariadic was called exactly once with the given values
func (f_sym6 *FakeVariadic) SingleVariadicCalledOnceWith(a ...string) bool {
	var count_sym6 int
	for _, call_sym6 := range f_sym6.SingleVariadicCalls {
		if reflect.DeepEqual(call_sym6.Parameters.A, a) {
			count_sym6++
		}
	}

	return count_sym6 == 1
}

// AssertSingleVariadicCalledOnceWith calls t.Error if FakeVariadic.SingleVariadic was not called exactly once with the given values
func (f_sym7 *FakeVariadic) AssertSingleVariadicCalledOnceWith(t VariadicTestingT, a ...string) {
	t.Helper()
	var count_sym7 int
	for _, call_sym7 := range f_sym7.SingleVariadicCalls {
		if reflect.DeepEqual(call_sym7.Parameters.A, a) {
			count_sym7++
		}
	}

	if count_sym7 != 1 {
		t.Errorf("FakeVariadic.SingleVariadic called %d times with expected parameters, expected one", count_sym7)
	}
}

func (f_sym8 *FakeVariadic) MixedVariadic(a int, b int, c int, d ...string) {
	if f_sym8.MixedVariadicHook == nil {
		panic("Variadic.MixedVariadic() called but FakeVariadic.MixedVariadicHook is nil")
	}

	invocation_sym8 := new(VariadicMixedVariadicInvocation)
	f_sym8.MixedVariadicCalls = append(f_sym8.MixedVariadicCalls, invocation_sym8)

	invocation_sym8.Parameters.A = a
	invocation_sym8.Parameters.B = b
	invocation_sym8.Parameters.C = c
	invocation_sym8.Parameters.D = d

	f_sym8.MixedVariadicHook(a, b, c, d...)

	return
}

// MixedVariadicCalled returns true if FakeVariadic.MixedVariadic was called
func (f *FakeVariadic) MixedVariadicCalled() bool {
	return len(f.MixedVariadicCalls) != 0
}

// AssertMixedVariadicCalled calls t.Error if FakeVariadic.MixedVariadic was not called
func (f *FakeVariadic) AssertMixedVariadicCalled(t VariadicTestingT) {
	t.Helper()
	if len(f.MixedVariadicCalls) == 0 {
		t.Error("FakeVariadic.MixedVariadic not called, expected at least one")
	}
}

// MixedVariadicNotCalled returns true if FakeVariadic.MixedVariadic was not called
func (f *FakeVariadic) MixedVariadicNotCalled() bool {
	return len(f.MixedVariadicCalls) == 0
}

// AssertMixedVariadicNotCalled calls t.Error if FakeVariadic.MixedVariadic was called
func (f *FakeVariadic) AssertMixedVariadicNotCalled(t VariadicTestingT) {
	t.Helper()
	if len(f.MixedVariadicCalls) != 0 {
		t.Error("FakeVariadic.MixedVariadic called, expected none")
	}
}

// MixedVariadicCalledOnce returns true if FakeVariadic.MixedVariadic was called exactly once
func (f *FakeVariadic) MixedVariadicCalledOnce() bool {
	return len(f.MixedVariadicCalls) == 1
}

// AssertMixedVariadicCalledOnce calls t.Error if FakeVariadic.MixedVariadic was not called exactly once
func (f *FakeVariadic) AssertMixedVariadicCalledOnce(t VariadicTestingT) {
	t.Helper()
	if len(f.MixedVariadicCalls) != 1 {
		t.Errorf("FakeVariadic.MixedVariadic called %d times, expected 1", len(f.MixedVariadicCalls))
	}
}

// MixedVariadicCalledN returns true if FakeVariadic.MixedVariadic was called at least n times
func (f *FakeVariadic) MixedVariadicCalledN(n int) bool {
	return len(f.MixedVariadicCalls) >= n
}

// AssertMixedVariadicCalledN calls t.Error if FakeVariadic.MixedVariadic was called less than n times
func (f *FakeVariadic) AssertMixedVariadicCalledN(t VariadicTestingT, n int) {
	t.Helper()
	if len(f.MixedVariadicCalls) < n {
		t.Errorf("FakeVariadic.MixedVariadic called %d times, expected >= %d", len(f.MixedVariadicCalls), n)
	}
}

// MixedVariadicCalledWith returns true if FakeVariadic.MixedVariadic was called with the given values
func (f_sym9 *FakeVariadic) MixedVariadicCalledWith(a int, b int, c int, d ...string) bool {
	for _, call_sym9 := range f_sym9.MixedVariadicCalls {
		if reflect.DeepEqual(call_sym9.Parameters.A, a) && reflect.DeepEqual(call_sym9.Parameters.B, b) && reflect.DeepEqual(call_sym9.Parameters.C, c) && reflect.DeepEqual(call_sym9.Parameters.D, d) {
			return true
		}
	}

	return false
}

// AssertMixedVariadicCalledWith calls t.Error if FakeVariadic.MixedVariadic was not called with the given values
func (f_sym10 *FakeVariadic) AssertMixedVariadicCalledWith(t VariadicTestingT, a int, b int, c int, d ...string) {
	t.Helper()
	var found_sym10 bool
	for _, call_sym10 := range f_sym10.MixedVariadicCalls {
		if reflect.DeepEqual(call_sym10.Parameters.A, a) && reflect.DeepEqual(call_sym10.Parameters.B, b) && reflect.DeepEqual(call_sym10.Parameters.C, c) && reflect.DeepEqual(call_sym10.Parameters.D, d) {
			found_sym10 = true
			break
		}
	}

	if !found_sym10 {
		t.Error("FakeVariadic.MixedVariadic not called with expected parameters")
	}
}

// MixedVariadicCalledOnceWith returns true if FakeVariadic.MixedVariadic was called exactly once with the given values
func (f_sym11 *FakeVariadic) MixedVariadicCalledOnceWith(a int, b int, c int, d ...string) bool {
	var count_sym11 int
	for _, call_sym11 := range f_sym11.MixedVariadicCalls {
		if reflect.DeepEqual(call_sym11.Parameters.A, a) && reflect.DeepEqual(call_sym11.Parameters.B, b) && reflect.DeepEqual(call_sym11.Parameters.C, c) && reflect.DeepEqual(call_sym11.Parameters.D, d) {
			count_sym11++
		}
	}

	return count_sym11 == 1
}

// AssertMixedVariadicCalledOnceWith calls t.Error if FakeVariadic.MixedVariadic was not called exactly once with the given values
func (f_sym12 *FakeVariadic) AssertMixedVariadicCalledOnceWith(t VariadicTestingT, a int, b int, c int, d ...string) {
	t.Helper()
	var count_sym12 int
	for _, call_sym12 := range f_sym12.MixedVariadicCalls {
		if reflect.DeepEqual(call_sym12.Parameters.A, a) && reflect.DeepEqual(call_sym12.Parameters.B, b) && reflect.DeepEqual(call_sym12.Parameters.C, c) && reflect.DeepEqual(call_sym12.Parameters.D, d) {
			count_sym12++
		}
	}

	if count_sym12 != 1 {
		t.Errorf("FakeVariadic.MixedVariadic called %d times with expected parameters, expected one", count_sym12)
	}
}
