// generated by "charlatan -dir=testdata/voider -output=testdata/voider/voider.go Voider".  DO NOT EDIT.

package main

import (
	"testing"
)

// VoidMethodInvocation represents a single call of FakeVoider.VoidMethod
type VoidMethodInvocation struct {
}

/*
FakeVoider is a mock implementation of Voider for testing.
Use it in your tests as in this example:

	package example

	func TestWithVoider(t *testing.T) {
		f := &main.FakeVoider{
			VoidMethodHook: func() () {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeVoidMethod ...
		f.AssertVoidMethodCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeVoidMethod.
*/
type FakeVoider struct {
	VoidMethodHook func()

	VoidMethodCalls []*VoidMethodInvocation
}

// NewFakeVoiderDefaultPanic returns an instance of FakeVoider with all hooks configured to panic
func NewFakeVoiderDefaultPanic() *FakeVoider {
	return &FakeVoider{
		VoidMethodHook: func() {
			panic("Unexpected call to Voider.VoidMethod")
		},
	}
}

// NewFakeVoiderDefaultFatal returns an instance of FakeVoider with all hooks configured to call t.Fatal
func NewFakeVoiderDefaultFatal(t *testing.T) *FakeVoider {
	return &FakeVoider{
		VoidMethodHook: func() {
			t.Fatal("Unexpected call to Voider.VoidMethod")
			return
		},
	}
}

// NewFakeVoiderDefaultError returns an instance of FakeVoider with all hooks configured to call t.Error
func NewFakeVoiderDefaultError(t *testing.T) *FakeVoider {
	return &FakeVoider{
		VoidMethodHook: func() {
			t.Error("Unexpected call to Voider.VoidMethod")
			return
		},
	}
}

func (_f1 *FakeVoider) VoidMethod() {
	invocation := new(VoidMethodInvocation)

	_f1.VoidMethodHook()

	_f1.VoidMethodCalls = append(_f1.VoidMethodCalls, invocation)

	return
}

// VoidMethodCalled returns true if FakeVoider.VoidMethod was called
func (f *FakeVoider) VoidMethodCalled() bool {
	return len(f.VoidMethodCalls) != 0
}

// AssertVoidMethodCalled calls t.Error if FakeVoider.VoidMethod was not called
func (f *FakeVoider) AssertVoidMethodCalled(t *testing.T) {
	t.Helper()
	if len(f.VoidMethodCalls) == 0 {
		t.Error("FakeVoider.VoidMethod not called, expected at least one")
	}
}

// VoidMethodNotCalled returns true if FakeVoider.VoidMethod was not called
func (f *FakeVoider) VoidMethodNotCalled() bool {
	return len(f.VoidMethodCalls) == 0
}

// AssertVoidMethodNotCalled calls t.Error if FakeVoider.VoidMethod was called
func (f *FakeVoider) AssertVoidMethodNotCalled(t *testing.T) {
	t.Helper()
	if len(f.VoidMethodCalls) != 0 {
		t.Error("FakeVoider.VoidMethod called, expected none")
	}
}

// VoidMethodCalledOnce returns true if FakeVoider.VoidMethod was called exactly once
func (f *FakeVoider) VoidMethodCalledOnce() bool {
	return len(f.VoidMethodCalls) == 1
}

// AssertVoidMethodCalledOnce calls t.Error if FakeVoider.VoidMethod was not called exactly once
func (f *FakeVoider) AssertVoidMethodCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.VoidMethodCalls) != 1 {
		t.Errorf("FakeVoider.VoidMethod called %d times, expected 1", len(f.VoidMethodCalls))
	}
}

// VoidMethodCalledN returns true if FakeVoider.VoidMethod was called at least n times
func (f *FakeVoider) VoidMethodCalledN(n int) bool {
	return len(f.VoidMethodCalls) >= n
}

// AssertVoidMethodCalledN calls t.Error if FakeVoider.VoidMethod was called less than n times
func (f *FakeVoider) AssertVoidMethodCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.VoidMethodCalls) < n {
		t.Errorf("FakeVoider.VoidMethod called %d times, expected >= %d", len(f.VoidMethodCalls), n)
	}
}
